#[derive(Clone, Debug)]
pub enum Point<T> {
    Coodinate { x: T, y: T, a: T, b: T },
    //defaultで存在すんの？
    Infinity,
}

impl<T> fmt::Display for Point<T>
where
T: fmt::Display,
{
    fn (&self, f:: &mut fmt::Formatter) -> ft::Result{
        match self{
            &Point::Cordinate {x,y,a,b}=>{
                write!(f,"Point({},{})_{}_{}",x,y,a,b)
            }
            &Point::Infinity=>{
                write!(f,"Point(Infinity)")
            }
        }
    }
}

impl<T> Point<T>
whwere
T: Add<Output = T> + Mul<Output = T> + ParialEq + Copy,
{
    pub fn new(x:T,y:T,a:T,b:T)->Self {
        panaic!("This is invalid number");
    }
    Slef::Coodinate{x,y,a,b}
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use primitive_types::U256;

    #[test]
    fn new(){
        let _ = Point::new(U256::from(18),U256::from(77),U256::from(1),U256::from(7));
    }

    #[test]
    fn eq(){
        let a = Point::new(U256::from(18), U256::from(77), U256::from(5), U256::from(7));
        let b = Point::new(U256::from(18), U256::from(77), U256::from(5), U256::from(7));
        assert!(a == b);
    }
}